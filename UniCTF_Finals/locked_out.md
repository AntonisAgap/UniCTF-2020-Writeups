# Locked Out  HTB x Uni CTF 2021 - Finals

***The creator provided us with a docker to connect to a web app and three files: *encryption.py*, *leaks* and *new_password****

Let's take a look at the files:

*leaks*
```
{'n':18627060853366003817633498319725128072935605420672144028180887821598995058566763870406708181052681986936527075954895204088200290386963730876047423903233595643471077586653831691013827267874620159258094222853259785361633293190228850242828942973252729075142510154777682987087560910570468443515976133521357279350135180187709921165306439775516983770374718903851808402718506713073936579721447055524042778187890314247383276126544626388594005451861656297486009721524593236438272682590796161812616558556489424502887789415628561091674949871825109470840186278129161368348123380425008804948098905894644488816022732318170994842927, 'rp': 228, 'rq': 75}
```
*new_password*
```
0x15f8468e603cfe7eca368ebf666b98d918686148336e2ffae048dc7dc7d4a399b1c6bff22140a79628c6a66e8d85fcc2d39505f15ec77295d373091c56a57de9472adf673d56307fa7fd2c7a3e2dc2d57c9380a5d332aa4c3592c08da22aa82667ebe7536a104e814c3f06dff9632f26fff3e52c711416abded102fa5377fce6dadcad3ac4d6197da69002817d00d3f765e71d73070fe1d5b1d8f1bf9a148ea026371c2d19debe317d96e9f1911f07286f90b8d9f9ff35d6b886f2f9b171b112f27e96c199e6f70501b282475c5ade73abe1c6bf39aada6507ab080aeccd11942171d83a28fb9c5aaeb7b40cf0a628946d6d46c40534e2fd3d65bf6e718435ce
```
*encryption.py*
```python
from Crypto.Util.number import *
from random import getrandbits
import random
import gmpy2
bits=1024


def generate_prime(bits):
	m = 2
	while True:
		a= getrandbits(bits)
		a = a**m
		prime = None
		r = None
		for i in range(2*a):
			if gmpy2.is_prime(a +i):
				prime = a +i
				r = i
				break
		if prime is None: continue
		return prime, r

p, rp = generate_prime(512)
q, rq = generate_prime(512)

n = p * q
e = 65537

msg = sys.argv[1].encode()

msg = bytes_to_long(msg)

ct = hex(pow(msg, e,n))

f = open('new_password', 'w')
f.write(ct)
f.close()

f = open('leaks', 'w')
f.write(str({'n':n, 'rp':rp, 'rq':rq}))
f.close()
```

Hmm... Interesting. We can see that a msg was encrypted using the RSA cipher. But the primes that were used to create *N* are generated by a custom function. Looking at the function we can see that it returns us the primes *p* and *q* and their LSBs(Least Significant Bits). N is calculated by: 

<a href="https://www.codecogs.com/eqnedit.php?latex=N&space;=pq=&space;(2a_{1}^{2}&space;&plus;&space;i_{1})(2a_{2}^{2}&plus;i_{2})" target="_blank"><img src="https://latex.codecogs.com/gif.latex?N&space;=pq=&space;(2a_{1}^{2}&space;&plus;&space;i_{1})(2a_{2}^{2}&plus;i_{2})" title="N =pq= (2a_{1}^{2} + i_{1})(2a_{2}^{2}+i_{2})" /></a>

After some searching on Google i came across this paper:

*Abd Ghafar, A.H.; Kamel Ariffin, M.R.; Asbullah, M.A. A New LSB Attack on Special-Structured RSA Primes. Symmetry 2020, 12, 838. https://doi.org/10.3390/sym12050838*

# A New LSB Attack on Special-Structured RSA Primes
In this paper the authors propose an attack where they successfully factored *N* in polynomial time using the following assumptions:
1. The primes *p* and *q* satisfy specific stuctures where: 

	<a href="https://www.codecogs.com/eqnedit.php?latex=p&space;=&space;a^{m}&space;&plus;&space;r_{p}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?p&space;=&space;a^{m}&space;&plus;&space;r_{p}" title="p = a^{m} + r_{p}" /></a>

	<a href="https://www.codecogs.com/eqnedit.php?latex=q&space;=&space;b_{m}&space;&plus;&space;r_{q}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?q&space;=&space;b_{m}&space;&plus;&space;r_{q}" title="q = b_{m} + r_{q}" /></a>

	<a href="https://www.codecogs.com/eqnedit.php?latex=a,b&space;\:&space;\epsilon&space;\:&space;\mathbb{Z}^{&plus;}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?a,b&space;\:&space;\epsilon&space;\:&space;\mathbb{Z}^{&plus;}" title="a,b \: \epsilon \: \mathbb{Z}^{+}" /></a>

	<a href="https://www.codecogs.com/eqnedit.php?latex=m&space;:&space;m&space;=&space;2n&space;\:&space;where\:&space;n\epsilon&space;N" target="_blank"><img src="https://latex.codecogs.com/gif.latex?m&space;:&space;m&space;=&space;2n&space;\:&space;where\:&space;n\epsilon&space;N" title="m : m = 2n \: where\: n\epsilon N" /></a>
2. The bits of&emsp;<a href="https://www.codecogs.com/eqnedit.php?latex=r_{p}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?r_{p}" title="r_{p}" /></a>&emsp;and&emsp;<a href="https://www.codecogs.com/eqnedit.php?latex=r_{q}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?r_{q}" title="r_{q}" /></a>&emsp;are the known LSBs of *p* and *q* respectively.

As we noticed before, those assumptions are true in this particular challenge because *a* and *b* are both positive integers and *m* is a positive even number i.e *m=2*.

The theorems and their proofs which this attack is based on are all very thoroughly and well explained in the paper, so i would suggest anyone who wants a deeper understanding of the attack to read it, but for now let's define the algorithm that we must use to factorize *N*.

*Factorization Algorithm:*

<a href="https://www.codecogs.com/eqnedit.php?latex=1.\,&space;set\,&space;N,rp,rq" target="_blank"><img src="https://latex.codecogs.com/gif.latex?1.\,&space;set\,&space;N,rp,rq" title="1.\, set\, N,rp,rq" /></a>

<a href="https://www.codecogs.com/eqnedit.php?latex=2.\,&space;set\,&space;i=\left&space;\lceil&space;(r_{p}r_{q})^{1/2}&space;\right&space;\rceil" target="_blank"><img src="https://latex.codecogs.com/gif.latex?2.\,&space;set\,&space;i=\left&space;\lceil&space;(r_{p}r_{q})^{1/2}&space;\right&space;\rceil" title="2.\, set\, i=\left \lceil (r_{p}r_{q})^{1/2} \right \rceil" /></a>

<a href="https://www.codecogs.com/eqnedit.php?latex=3.\,&space;while\;&space;True:" target="_blank"><img src="https://latex.codecogs.com/gif.latex?3.\,&space;while\;&space;True:" title="3.\, while\; True:" /></a>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://www.codecogs.com/eqnedit.php?latex=\;&space;4.\,&space;\sigma&space;=(\left&space;[&space;\sqrt{N}&space;\right&space;]&space;-&space;i)^{2}\;&space;and\:&space;z\equiv&space;N-(r_{p}r_{q})(mod\sigma&space;)" target="_blank"><img src="https://latex.codecogs.com/gif.latex?\;&space;1.\,&space;\sigma&space;=(\left&space;[&space;\sqrt{N}&space;\right&space;]&space;-&space;i)^{2}\;&space;and\:&space;z\equiv&space;N-(r_{p}r_{q})(mod\sigma&space;)" title="\; 1.\, \sigma =(\left [ \sqrt{N} \right ] - i)^{2}\; and\: z\equiv N-(r_{p}r_{q})(mod\sigma )" /></a>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://www.codecogs.com/eqnedit.php?latex=2.\,&space;solve\,&space;x_{1,2}=X^{2}-zX&plus;\sigma&space;r_{p}r_{q}=0" target="_blank"><img src="https://latex.codecogs.com/gif.latex?2.\,&space;solve\,&space;x_{1,2}=X^{2}-zX&plus;\sigma&space;r_{p}r_{q}=0" title="5.\, solve\, x_{1,2}=X^{2}-zX+\sigma r_{p}r_{q}=0" /></a>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://www.codecogs.com/eqnedit.php?latex=3.\,&space;if\,&space;(\frac{x_{1}}{r_{q}}&plus;r_{p}),(\frac{x_{2}}{r_{p}}&plus;r_{q})&space;\epsilon&space;\mathbb{Z}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?3.\,&space;if\,&space;(\frac{x_{1}}{r_{q}}&plus;r_{p}),(\frac{x_{2}}{r_{p}}&plus;r_{q})&space;\epsilon&space;\mathbb{Z}" title="6.\, if\, (\frac{x_{1}}{r_{q}}+r_{p}),(\frac{x_{2}}{r_{p}}+r_{q}) \epsilon \mathbb{Z}" /></a>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://www.codecogs.com/eqnedit.php?latex=7.break" target="_blank"><img src="https://latex.codecogs.com/gif.latex?1.break" title="7.break" /></a>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://www.codecogs.com/eqnedit.php?latex=4.\,&space;i&plus;&plus;" target="_blank"><img src="https://latex.codecogs.com/gif.latex?4.\,&space;i&plus;&plus;" title="4.\, i++" /></a>

<a href="https://www.codecogs.com/eqnedit.php?latex=4.\,&space;p&space;=&space;\frac{N}{\frac{x_{1}}{r_{q}}&plus;r_{p}},\,&space;q=\frac{N}{\frac{x_{2}}{r_{p}}&plus;r_{q}}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?4.\,&space;p&space;=&space;\frac{N}{\frac{x_{1}}{r_{q}}&plus;r_{p}},\,&space;q=\frac{N}{\frac{x_{2}}{r_{p}}&plus;r_{q}}" title="4.\, p = \frac{N}{\frac{x_{1}}{r_{q}}+r_{p}},\, q=\frac{N}{\frac{x_{2}}{r_{p}}+r_{q}}" /></a>

So the algorithms successfully factorizes *N* and because the search for the integer *i* should be less than &nbsp;<a href="https://www.codecogs.com/eqnedit.php?latex=\frac{r_{q}}{2}&plus;2^{\frac{m}{2}-1}r_{p}&plus;1" target="_blank"><img src="https://latex.codecogs.com/gif.latex?\frac{r_{q}}{2}&plus;2^{\frac{m}{2}-1}r_{p}&plus;1" title="\frac{r_{q}}{2}+2^{\frac{m}{2}-1}r_{p}+1" /></a>,&nbsp;it factorizes *N* in *polynomial* time.

Let's implement the algorithm. For the sake of ease i implemented it on a SageMath notebook using Python.

```python
n = 18627060853366003817633498319725128072935605420672144028180887821598995058566763870406708181052681986936527075954895204088200290386963730876047423903233595643471077586653831691013827267874620159258094222853259785361633293190228850242828942973252729075142510154777682987087560910570468443515976133521357279350135180187709921165306439775516983770374718903851808402718506713073936579721447055524042778187890314247383276126544626388594005451861656297486009721524593236438272682590796161812616558556489424502887789415628561091674949871825109470840186278129161368348123380425008804948098905894644488816022732318170994842927
e = 65537
rp = 228
rq = 75
# calculating i
i = (rp*rq)**(1/2)
i = ceil(i)

while True:
    s = (floor(sqrt(n)) - i)**2
    z = (n - (rp*rq))%s
    eq = x^2 - z*x + (s*rp*rq)
    solves = eq.roots(x)
    x1 = solves[0][0]
    x2 = solves[1][0]
    check1 = (x1/rq) + rp
    check2 = (x2/rp) + rq
    check1 = check1 in ZZ
    check2 = check2 in ZZ
    if (check1 & check2):
        break
    i = i + 1

s = (floor(sqrt(n)) - i)**2
z = (n - (rp*rq))%s
eq = x^2 - z*x + (s*rp*rq)
solves = eq.roots(x)
x1 = solves[0][0]
x2 = solves[1][0]

p = n/((x1/rq)+rp)
q = n/((x2/rp)+rq)
print("p:",p)
print("q:",q)
```
*output:*
```
p: 123880731118078606990137525967538331116275498654165135288667481763468359990787854975994876893087359471477116036463781441086420155388498641200190619570949282848164235074476184966442200869534040008670271367209107524675332904145907801965290873060668160752216813566725872730131480362642158718779920761925401528651
q: 150362858575732548219754570301381634122999263516619646855675710330030496390597605066461381496132938312364517714698445634122472027371009904402523096814969573630139999346443540376793118417308745137884179413367200916679151666589105220887354180335290484032521243626622947122613757089607520963969953938000225816877
```
Perfect! Now all we have to do is calculate *d*. To do that we must find <a href="https://www.codecogs.com/eqnedit.php?latex=d\equiv&space;e^{-1}(mod\,&space;phi)" target="_blank"><img src="https://latex.codecogs.com/gif.latex?d\equiv&space;e^{-1}(mod\,&space;phi)" title="d\equiv e^{-1}(mod\, phi)" /></a>,
where&nbsp; <a href="https://www.codecogs.com/eqnedit.php?latex=phi&space;=&space;(p-1)(q-1)" target="_blank"><img src="https://latex.codecogs.com/gif.latex?phi&space;=&space;(p-1)(q-1)" title="phi = (p-1)(q-1)" /></a>

To do that we use the extended Euclidian algorithm. After we find the key *d* the only thing that is left is to decrypt the ciphertext. Let's code that in Python.
```python
import math
from Crypto.Util.number import *
from sagemath import *


p = 123880731118078606990137525967538331116275498654165135288667481763468359990787854975994876893087359471477116036463781441086420155388498641200190619570949282848164235074476184966442200869534040008670271367209107524675332904145907801965290873060668160752216813566725872730131480362642158718779920761925401528651
q = 150362858575732548219754570301381634122999263516619646855675710330030496390597605066461381496132938312364517714698445634122472027371009904402523096814969573630139999346443540376793118417308745137884179413367200916679151666589105220887354180335290484032521243626622947122613757089607520963969953938000225816877
e = 65537
n = 18627060853366003817633498319725128072935605420672144028180887821598995058566763870406708181052681986936527075954895204088200290386963730876047423903233595643471077586653831691013827267874620159258094222853259785361633293190228850242828942973252729075142510154777682987087560910570468443515976133521357279350135180187709921165306439775516983770374718903851808402718506713073936579721447055524042778187890314247383276126544626388594005451861656297486009721524593236438272682590796161812616558556489424502887789415628561091674949871825109470840186278129161368348123380425008804948098905894644488816022732318170994842927
ct = "0x15f8468e603cfe7eca368ebf666b98d918686148336e2ffae048dc7dc7d4a399b1c6bff22140a79628c6a66e8d85fcc2d39505f15ec77295d373091c56a57de9472adf673d56307fa7fd2c7a3e2dc2d57c9380a5d332aa4c3592c08da22aa82667ebe7536a104e814c3f06dff9632f26fff3e52c711416abded102fa5377fce6dadcad3ac4d6197da69002817d00d3f765e71d73070fe1d5b1d8f1bf9a148ea026371c2d19debe317d96e9f1911f07286f90b8d9f9ff35d6b886f2f9b171b112f27e96c199e6f70501b282475c5ade73abe1c6bf39aada6507ab080aeccd11942171d83a28fb9c5aaeb7b40cf0a628946d6d46c40534e2fd3d65bf6e718435ce"


def getModInverse(a, m):
    if math.gcd(a, m) != 1:
        return None
    u1, u2, u3 = 1, 0, a
    v1, v2, v3 = 0, 1, m

    while v3 != 0:
        q = u3 // v3
        v1, v2, v3, u1, u2, u3 = (
            u1 - q * v1), (u2 - q * v2), (u3 - q * v3), v1, v2, v3
    return u1 % m

phi = (p - 1) * (q - 1)
d = getModInverse(e, phi)
ct = int(ct,16)
pt = pow(ct, d, n)

pt = long_to_bytes(pt)
print(pt)
```
*output*
```
b'The password is 4p7gr0p0w3ndU'
```
Perfect! We found the password,now we can use it to login as an admin on the web app, which gives us the flag.
```
HTB{}
```